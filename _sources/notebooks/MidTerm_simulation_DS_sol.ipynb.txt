{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Module 2 - Midterm simulation test SOLUTIONS\n",
    "\n",
    "This is the second DS MidTerm exam provided in December 2022.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Practical part\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Excercise 3\n",
    "\n",
    "Bubble sort is a sorting algorithm that compares two adjacent elements and swaps them until they are in the intended order.\n",
    "Just like the movement of air bubbles in the water that rise up to the surface, the maximum element of the array moves to the end in each iteration. \n",
    "Therefore, it is called a bubble sort.\n",
    "\n",
    "1. The idea is to scan multiple times the list and when you find two elements in the wrong order you swap them.\n",
    "2. If at the end of a scan you did not swap any elements then your list is sorted\n",
    "\n",
    "After the first scan the max is at the last position, at the second scan the \"second max\" is at the second-last position and so on. \n",
    "\n",
    "Below you can see and example of the bubble sort execution \n",
    "\n",
    "![](images/bubb.png)\n",
    "\n",
    "**Implement the bubble sort algorithm by filling the method below**\n",
    "\n",
    "Then, test it on a random array of 500 elements and check its correctness. Finally, analyze the time complexity of this algorithm."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Before sorting:\n",
      "\n",
      "[7, 5, 10, -11, 3, -4, 99, 1]\n",
      "After sorting:\n",
      "\n",
      "[-11, -4, 1, 3, 5, 7, 10, 99]\n",
      "\n",
      "Number of elements: 1000\n",
      "Number of comparisons: 499485\n",
      "Number of swaps: 257146\n",
      "\n",
      "Number of elements: 2000\n",
      "Number of comparisons: 1997569\n",
      "Number of swaps: 995732\n",
      "\n",
      "Sorting test passed? True\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "\n",
    "class SortingAlgorithm:\n",
    "    def __init__(self, data, verbose = True):\n",
    "        self.data = data\n",
    "        self.comparisons = 0\n",
    "        self.operations = 0\n",
    "        self.verbose = verbose\n",
    "        \n",
    "    def getData(self):\n",
    "        return self.data\n",
    "    \n",
    "    def getOperations(self):\n",
    "        return self.operations\n",
    "    \n",
    "    def getComparisons(self):\n",
    "        return self.comparisons\n",
    "\n",
    "    def sort(self):\n",
    "        raise NotImplementedError\n",
    "\n",
    "class BubbleSort(SortingAlgorithm):\n",
    "    \n",
    "    def sort(self):\n",
    "        self.comparisons = 0\n",
    "        self.operations = 0\n",
    "        n = len(self.data)\n",
    "        #stop if no no swaps are found in an iteration\n",
    "        for i in range(n-1):\n",
    "            swapped = False\n",
    "            for j in range(0, n-i-1):\n",
    "                if self.data[j] > self.data[j + 1]:\n",
    "                    self.data[j], self.data[j + 1] = self.data[j + 1], self.data[j]\n",
    "                    swapped = True\n",
    "                    self.operations += 1\n",
    "                \n",
    "                self.comparisons += 1\n",
    "\n",
    "            if not swapped:\n",
    "                break\n",
    "    \n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "\n",
    "    d = [7, 5, 10, -11 ,3, -4, 99, 1]\n",
    "    print(\"Before sorting:\\n\")\n",
    "    print(d)\n",
    "    bubSorter = BubbleSort(d, verbose = True)\n",
    "    bubSorter.sort()\n",
    "    print(\"After sorting:\\n\")\n",
    "    print(d)\n",
    "    d = []\n",
    "\n",
    "    for i in range(0,1000):\n",
    "        d.append(random.randint(0,1000))\n",
    "    bubSorter = BubbleSort(d)\n",
    "    bubSorter.sort()\n",
    "    print(\"\\nNumber of elements: {}\".format(len(d)))\n",
    "    print(\"Number of comparisons: {}\".format(bubSorter.getComparisons()))\n",
    "    print(\"Number of swaps: {}\".format(bubSorter.getOperations()))\n",
    "    \n",
    "    d = []\n",
    "    for i in range(0,2000):\n",
    "        d.append(random.randint(0,1000))\n",
    "    bubSorter = BubbleSort(d)\n",
    "    bubSorter.sort()\n",
    "    print(\"\\nNumber of elements: {}\".format(len(d)))\n",
    "    print(\"Number of comparisons: {}\".format(bubSorter.getComparisons()))\n",
    "    print(\"Number of swaps: {}\".format(bubSorter.getOperations()))\n",
    "    \n",
    "    test = True\n",
    "    for el in range(0,len(d)-1):\n",
    "        test = test and (d[el]<= d[el+1])\n",
    "    print(\"\\nSorting test passed? {}\".format(test))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Complexity O(n^2 )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercise 4\n",
    "\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given a binary search tree as the one provided in the code chunck below, implement the missing function `search_interval(a, b)` that given two values `a` and `b`, finds all values between `a` and `b` in the tree, returning them in an ordered data structure. For instance, calling `search_interval(24, 33)` on the following tree should return: `[24, 26, 31, 32]`.\n",
    "\n",
    "![](images/Graph2.png)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Elements between 24 and 33 in the BST:\n",
      "[24, 25, 26, 27, 28, 30, 31, 32]\n"
     ]
    }
   ],
   "source": [
    "class BinaryTree:\n",
    "    def __init__(self, value):\n",
    "        self.__data = value\n",
    "        self.__right = None\n",
    "        self.__left = None\n",
    "        self.__parent = None\n",
    "        self.__depth = 0\n",
    "    \n",
    "    def getDepth(self):\n",
    "        return self.__depth    \n",
    "    def setDepth(self, newdepth):\n",
    "        self.__depth = newdepth\n",
    "\n",
    "    def getValue(self):\n",
    "        return self.__data\n",
    "    def setValue(self, newValue):\n",
    "        self.__data = newValue\n",
    "    \n",
    "    def getParent(self):\n",
    "        return self.__parent\n",
    "    def setParent(self, tree):\n",
    "        self.__parent = tree\n",
    "    \n",
    "    def getRight(self):\n",
    "        return self.__right\n",
    "    def getLeft(self):\n",
    "        return self.__left\n",
    "    \n",
    "    def insertRight(self, tree):\n",
    "        if self.__right == None:\n",
    "            self.__right = tree\n",
    "            tree.setParent(self)\n",
    "            tree.setDepth(self.getDepth() + 1)                \n",
    "    def insertLeft(self, tree):\n",
    "        if self.__left == None:\n",
    "            self.__left = tree\n",
    "            tree.setDepth(self.getDepth() + 1)\n",
    "            tree.setParent(self)\n",
    "            \n",
    "    def deleteRight(self):\n",
    "        self.__right = None   \n",
    "    def deleteLeft(self):\n",
    "        self.__left = None\n",
    "        \n",
    "    def inOrderDFS(self):\n",
    "        ret = []\n",
    "        if self != None:\n",
    "            r = self.getRight()\n",
    "            l = self.getLeft()\n",
    "            if l != None:\n",
    "                ret.extend(l.inOrderDFS())\n",
    "            ret.append(self.getValue())\n",
    "            if r != None:\n",
    "                ret.extend(r.inOrderDFS())\n",
    "        return ret\n",
    "\n",
    "    def search_interval(self, a, b):\n",
    "        # implemented function!\n",
    "        greaterThanMin = a < self.__data\n",
    "        lowerThanMax = b > self.__data\n",
    "\n",
    "        elements = []\n",
    "\n",
    "        if greaterThanMin:\n",
    "            if (self.__left != None):\n",
    "                elements.extend(self.__left.search_interval(a, b))\n",
    "\n",
    "        if (a <= self.__data <= b):\n",
    "            elements.append(self.__data)\n",
    "\n",
    "        if lowerThanMax:\n",
    "            if (self.__right != None):\n",
    "                elements.extend(self.__right.search_interval(a, b))\n",
    "\n",
    "        return(elements)\n",
    "\n",
    "def createBST(intList):\n",
    "    BST = None\n",
    "    if len(intList) > 0:\n",
    "        BST = BinaryTree(intList[0])\n",
    "        for el in intList[1:]:\n",
    "            cur_el = BST\n",
    "            alreadyPresent = False\n",
    "            prev_el = None\n",
    "            while cur_el != None:\n",
    "                prev_el = cur_el\n",
    "                cv = cur_el.getValue()\n",
    "                if  cv > el:\n",
    "                    cur_el = cur_el.getLeft()\n",
    "                elif cv < el:\n",
    "                    cur_el = cur_el.getRight()\n",
    "                else:\n",
    "                    # cv == el (el is already present)\n",
    "                    # not allowed by rule c, so skip it\n",
    "                    alreadyPresent = True\n",
    "                    #print(\"El {} already present\".format(el))\n",
    "                    break\n",
    "                \n",
    "            if not alreadyPresent:\n",
    "                node = BinaryTree(el)\n",
    "                node.setParent(prev_el)\n",
    "                if prev_el.getValue() > el:\n",
    "                    prev_el.insertLeft(node)\n",
    "                else:\n",
    "                    prev_el.insertRight(node)\n",
    "                \n",
    "    return BST\n",
    "    \n",
    "\n",
    "def printTree(root):\n",
    "    cur = root\n",
    "    #each element is a node and a depth\n",
    "    #depth is used to format prints (with tabs)\n",
    "    nodes = [(cur,0)]\n",
    "    tabs = \"\"\n",
    "    lev = 0\n",
    "    while len(nodes) >0:\n",
    "        cur, lev = nodes.pop(-1)\n",
    "        if cur.getRight() != None:\n",
    "            print (\"{}{} (r)-> {}\".format(\"\\t\"*lev, \n",
    "                                          cur.getValue(), \n",
    "                                          cur.getRight().getValue()))\n",
    "            nodes.append((cur.getRight(), lev+1))\n",
    "        if cur.getLeft() != None:\n",
    "            print (\"{}{} (l)-> {}\".format(\"\\t\"*lev, \n",
    "                                          cur.getValue(), \n",
    "                                          cur.getLeft().getValue()))\n",
    "            nodes.append((cur.getLeft(), lev+1))\n",
    "       \n",
    "    \n",
    "if __name__ == \"__main__\":\n",
    "    import random\n",
    "\n",
    "    inList = []\n",
    "    for i in range(1000):\n",
    "        inList.append(random.randint(0,1000))\n",
    "        \n",
    "    #printTree(createBST(inList[:20])) # to test tree creation...\n",
    "    \n",
    "    BST = createBST(inList)\n",
    "            \n",
    "    sorted = BST.search_interval(24, 33)\n",
    "    print(\"Elements between 24 and 33 in the BST:\")\n",
    "    print(sorted)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.15"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "40c5a1e5e9beb9a52b32dc62c9941cbcbeb1c8fcbfea2c261c390e1a1bc44a33"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
