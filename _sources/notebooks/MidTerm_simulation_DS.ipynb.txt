{
 "cells": [
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Module 2 - Midterm simulation test\n",
    "\n",
    "This is the second DS MidTerm exam provided in December 2023.\n",
    "\n",
    "Please, refer to Prof. Alessandro Romanel for any comments on the theoretical part.\n",
    "\n",
    "Solutions for the practical part will be provided later today (or tomorrow).\n",
    "\n",
    "## Theoretical part\n",
    "\n",
    "### Exercise 1\n",
    "Given a list ùêø of ùëõ‚â•3 integer elements, please compute the asymptotic computational complexity of the following function, explaining your reasoning."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "def my_fun(L):\n",
    "    for i in range(3, len(L)):\n",
    "        k = 0\n",
    "        R = L[i]\n",
    "        tmp = []\n",
    "        while k < 3:\n",
    "            if k % 2 == 1:\n",
    "                R = R - L[k]\n",
    "            else:\n",
    "                R = R + L[k]\n",
    "            k += 1\n",
    "        tmp.append(R)\n",
    "\n",
    "    return sum(tmp)"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercise 2\n",
    "What is the topological sorting of a directed acyclic graph (DAG)? Briefly describe an algorithm to compute it and provide a possible topological view of the following DAG.\n",
    "\n",
    "![](images/graph_1_sim.png)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Practical part\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercise 3\n",
    "\n",
    "Bubble sort is a sorting algorithm that compares two adjacent elements and swaps them until they are in the intended order.\n",
    "Just like the movement of air bubbles in the water that rise up to the surface, the maximum element of the array moves to the end in each iteration. \n",
    "Therefore, it is called a bubble sort.\n",
    "\n",
    "1. The idea is to scan multiple times the list and when you find two elements in the wrong order you swap them.\n",
    "2. If at the end of a scan you did not swap any elements then your list is sorted\n",
    "\n",
    "After the first scan the max is at the last position, at the second scan the \"second max\" is at the second-last position and so on. \n",
    "\n",
    "Below you can see and example of the bubble sort execution \n",
    "\n",
    "![](images/bubb.png)\n",
    "\n",
    "**Implement the bubble sort algorithm by filling the sort method below**\n",
    "\n",
    "Then, test it on a random array of 500 elements and check its correctness. Finally, analyze the time complexity of this algorithm.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Before sorting:\n",
      "\n",
      "[7, 5, 10, -11, 3, -4, 99, 1]\n",
      "After sorting:\n",
      "\n",
      "[7, 5, 10, -11, 3, -4, 99, 1]\n"
     ]
    }
   ],
   "source": [
    "import random\n",
    "\n",
    "class SortingAlgorithm:\n",
    "    def __init__(self, data, verbose = True):\n",
    "        self.data = data\n",
    "        self.comparisons = 0\n",
    "        self.operations = 0\n",
    "        self.verbose = verbose\n",
    "        \n",
    "    def getData(self):\n",
    "        return self.data\n",
    "    \n",
    "    def getOperations(self):\n",
    "        return self.operations\n",
    "    \n",
    "    def getComparisons(self):\n",
    "        return self.comparisons\n",
    "\n",
    "    def sort(self):\n",
    "        raise NotImplementedError\n",
    "\n",
    "class BubbleSort(SortingAlgorithm):\n",
    "    \n",
    "\n",
    "    def sort(self):\n",
    "        self.comparisons = 0\n",
    "        self.operations = 0\n",
    "        \"\"\"\n",
    "        to implement\n",
    "        \"\"\"\n",
    "        \n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "\n",
    "    d = [7, 5, 10, -11 ,3, -4, 99, 1]\n",
    "    print(\"Before sorting:\\n\")\n",
    "    print(d)\n",
    "    bubSorter = BubbleSort(d, verbose = True)\n",
    "    bubSorter.sort()\n",
    "    print(\"After sorting:\\n\")\n",
    "    print(d)\n",
    " \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercise 4\n",
    "\n",
    "\n"
   ]
  },
  {
   "attachments": {},
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given a binary search tree as the one provided in the code chunck below, implement the missing function `search_interval(a, b)` that given two values `a` and `b`, finds all values between `a` and `b` in the tree, returning them in an ordered data structure. For instance, calling `search_interval(24, 33)` on the following tree should return: `[24, 26, 31, 32]`.\n",
    "\n",
    "![](images/Graph2.png)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class BinaryTree:\n",
    "    def __init__(self, value):\n",
    "        self.__data = value\n",
    "        self.__right = None\n",
    "        self.__left = None\n",
    "        self.__parent = None\n",
    "        self.__depth = 0\n",
    "    \n",
    "    def getDepth(self):\n",
    "        return self.__depth    \n",
    "    def setDepth(self, newdepth):\n",
    "        self.__depth = newdepth\n",
    "\n",
    "    def getValue(self):\n",
    "        return self.__data\n",
    "    def setValue(self, newValue):\n",
    "        self.__data = newValue\n",
    "    \n",
    "    def getParent(self):\n",
    "        return self.__parent\n",
    "    def setParent(self, tree):\n",
    "        self.__parent = tree\n",
    "    \n",
    "    def getRight(self):\n",
    "        return self.__right\n",
    "    def getLeft(self):\n",
    "        return self.__left\n",
    "    \n",
    "    def insertRight(self, tree):\n",
    "        if self.__right == None:\n",
    "            self.__right = tree\n",
    "            tree.setParent(self)\n",
    "            tree.setDepth(self.getDepth() + 1)                \n",
    "    def insertLeft(self, tree):\n",
    "        if self.__left == None:\n",
    "            self.__left = tree\n",
    "            tree.setDepth(self.getDepth() + 1)\n",
    "            tree.setParent(self)\n",
    "            \n",
    "    def deleteRight(self):\n",
    "        self.__right = None   \n",
    "    def deleteLeft(self):\n",
    "        self.__left = None\n",
    "        \n",
    "    def inOrderDFS(self):\n",
    "        ret = []\n",
    "        if self != None:\n",
    "            r = self.getRight()\n",
    "            l = self.getLeft()\n",
    "            if l != None:\n",
    "                ret.extend(l.inOrderDFS())\n",
    "            ret.append(self.getValue())\n",
    "            if r != None:\n",
    "                ret.extend(r.inOrderDFS())\n",
    "        return ret\n",
    "\n",
    "    def search_interval(self, a, b):\n",
    "        raise NotImplementedError\n",
    "\n",
    "def createBST(intList):\n",
    "    BST = None\n",
    "    if len(intList) > 0:\n",
    "        BST = BinaryTree(intList[0])\n",
    "        for el in intList[1:]:\n",
    "            cur_el = BST\n",
    "            alreadyPresent = False\n",
    "            prev_el = None\n",
    "            while cur_el != None:\n",
    "                prev_el = cur_el\n",
    "                cv = cur_el.getValue()\n",
    "                if  cv > el:\n",
    "                    cur_el = cur_el.getLeft()\n",
    "                elif cv < el:\n",
    "                    cur_el = cur_el.getRight()\n",
    "                else:\n",
    "                    # cv == el (el is already present)\n",
    "                    # not allowed by rule c, so skip it\n",
    "                    alreadyPresent = True\n",
    "                    #print(\"El {} already present\".format(el))\n",
    "                    break\n",
    "                \n",
    "            if not alreadyPresent:\n",
    "                node = BinaryTree(el)\n",
    "                node.setParent(prev_el)\n",
    "                if prev_el.getValue() > el:\n",
    "                    prev_el.insertLeft(node)\n",
    "                else:\n",
    "                    prev_el.insertRight(node)\n",
    "                \n",
    "    return BST\n",
    "    \n",
    "\n",
    "def printTree(root):\n",
    "    cur = root\n",
    "    #each element is a node and a depth\n",
    "    #depth is used to format prints (with tabs)\n",
    "    nodes = [(cur,0)]\n",
    "    tabs = \"\"\n",
    "    lev = 0\n",
    "    while len(nodes) >0:\n",
    "        cur, lev = nodes.pop(-1)\n",
    "        if cur.getRight() != None:\n",
    "            print (\"{}{} (r)-> {}\".format(\"\\t\"*lev, \n",
    "                                          cur.getValue(), \n",
    "                                          cur.getRight().getValue()))\n",
    "            nodes.append((cur.getRight(), lev+1))\n",
    "        if cur.getLeft() != None:\n",
    "            print (\"{}{} (l)-> {}\".format(\"\\t\"*lev, \n",
    "                                          cur.getValue(), \n",
    "                                          cur.getLeft().getValue()))\n",
    "            nodes.append((cur.getLeft(), lev+1))\n",
    "       \n",
    "    \n",
    "if __name__ == \"__main__\":\n",
    "    import random\n",
    "\n",
    "    inList = []\n",
    "    for i in range(1000):\n",
    "        inList.append(random.randint(0,1000))\n",
    "        \n",
    "    #printTree(createBST(inList[:20])) # to test tree creation...\n",
    "    \n",
    "    BST = createBST(inList)\n",
    "            \n",
    "    sorted = BST.search_interval(24, 33)\n",
    "    print(\"Elements between 24 and 33 in the BST:\")\n",
    "    print(sorted)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.8.5 ('base')",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.15"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "40c5a1e5e9beb9a52b32dc62c9941cbcbeb1c8fcbfea2c261c390e1a1bc44a33"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
